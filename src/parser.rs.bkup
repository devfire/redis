// borrowed from https://raw.githubusercontent.com/pawelkobojek/respirator/main/src/parser.rs
use nom::{
    bytes::complete::{take, tag, take_while},
    character::complete::{crlf, not_line_ending},
    number::complete,

    multi::count,
    combinator::{map_res, map},
    sequence::{terminated, tuple, delimited, preceded},
    IResult, branch::alt,
};

use crate::protocol::{RespFrame, Command};

pub fn parse_resp(input: &[u8]) -> IResult<&[u8], RespFrame> {
    let (input, val) = take(1usize)(input)?;
    match val[0] {
        b'+' => simple_string(input),
        b':' => integer(input),
        b'-' => error(input),
        b'$' => bulk_string(input),
        b'*' => array(input),
        _ => panic!("Unknown type byte: {:?}", val),
    }
}

fn simple_string(input: &[u8]) -> IResult<&[u8], RespFrame> {
    let (input, val) = terminated(not_line_ending, crlf)(input)?;
    Ok((input, RespFrame::SimpleString(val.to_vec())))
}

fn integer(input: &[u8]) -> IResult<&[u8], RespFrame> {
    let (input, val) = terminated(not_line_ending, crlf)(input)?;
    Ok((
        input,
        RespFrame::Integer(String::from_utf8_lossy(val).parse::<i64>().unwrap()),
    ))
}

fn error(input: &[u8]) -> IResult<&[u8], RespFrame> {
    let (input, val) = terminated(not_line_ending, crlf)(input)?;
    Ok((input, RespFrame::Error(val.to_vec())))
}

fn bulk_string(input: &[u8]) -> IResult<&[u8], RespFrame> {
    let (input, len) = length(input)?;
    if len == 0 {
        return Ok((input, RespFrame::BulkString(None)));
    }
    let (input, val) = terminated(take(len), crlf)(input)?;

    Ok((input, RespFrame::BulkString(Some(val.to_vec()))))
}

fn parse_number(input: &[u8]) -> IResult<&[u8], u32> {
    let (input, val) = terminated(not_line_ending, crlf)(input)?;
    Ok((
        input,
        RespFrame::Integer(String::from_utf8_lossy(val).parse::<i64>().unwrap()),
    ))
}

fn parse_bulk_string(input: &str) -> IResult<&str, &str> {
    preceded(
        delimited(tag("$"), parse_number, tag("\r\n")),
        take_while(|c: char| c != '\r'),
    )(input)
 }

fn length(input: &[u8]) -> IResult<&[u8], usize> {
    let (input, len) = terminated(not_line_ending, crlf)(input)?;
    Ok((input, String::from_utf8_lossy(len).parse().unwrap()))
}

fn array(input: &[u8]) -> IResult<&[u8], RespFrame> {
    let (input, len) = length(input)?;
    if len == 0 {
        return Ok((input, RespFrame::Array(None)));
    }
    let (input, res) = count(parse_resp, len)(input)?;
    Ok((input, RespFrame::Array(Some(res))))
}

fn parse_echo_command(input: &str) -> IResult<&str, &str> {
    map(
        tuple((
            delimited(tag("*2\r\n"), tag(r"\$4\r\nECHO\r\n"), tag("\r\n")),
            parse_bulk_string,
        )),
        |(_command_name, message)| message,
    )(input)
 }

 fn parse_command(input: &str) -> IResult<&str, Command> {
    alt((
        map(tag(r"*1\r\n\$4\r\nPING\r\n"), |_| Command::Ping),
        map(parse_echo_command, |msg| Command::Echo(msg.into())),
        // Map other commands here
    ))(input)
}